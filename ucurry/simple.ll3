; ModuleID = 'uCurry'
source_filename = "uCurry"

@fmt = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@fmt.1 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@fmt.2 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@fmt.3 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@unit = private unnamed_addr constant [3 x i8] c"()\00", align 1
@unitln = private unnamed_addr constant [4 x i8] c"()\0A\00", align 1

define i32 @main(i32 %0) {
entry:
  %x = alloca { i8* ()*, i8*, i1 }*, align 8
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8* ()*, i8*, i1 }* getelementptr ({ i8* ()*, i8*, i1 }, { i8* ()*, i8*, i1 }* null, i32 1) to i32))
  %thunk_sturct = bitcast i8* %malloccall to { i8* ()*, i8*, i1 }*
  %malloccall1 = tail call i8* @malloc(i32 ptrtoint ({ i32 (i8*, i1)*, i8* }* getelementptr ({ i32 (i8*, i1)*, i8* }, { i32 (i8*, i1)*, i8* }* null, i32 1) to i32))
  %fun_closure = bitcast i8* %malloccall1 to { i32 (i8*, i1)*, i8* }*
  %malloccall2 = tail call i8* @malloc(i32 ptrtoint ({}* getelementptr ({}, {}* null, i32 1) to i32))
  %captured_struct = bitcast i8* %malloccall2 to {}*
  %capstruct = bitcast {}* %captured_struct to i8*
  %struct_field = getelementptr inbounds { i32 (i8*, i1)*, i8* }, { i32 (i8*, i1)*, i8* }* %fun_closure, i32 0, i32 0
  store i32 (i8*, i1)* @lambda, i32 (i8*, i1)** %struct_field, align 8
  %struct_field3 = getelementptr inbounds { i32 (i8*, i1)*, i8* }, { i32 (i8*, i1)*, i8* }* %fun_closure, i32 0, i32 1
  store i8* %capstruct, i8** %struct_field3, align 8
  %casted_delay_fun = bitcast { i32 (i8*, i1)*, i8* }* %fun_closure to i8* ()*
  %struct_field4 = getelementptr inbounds { i8* ()*, i8*, i1 }, { i8* ()*, i8*, i1 }* %thunk_sturct, i32 0, i32 0
  store i8* ()* %casted_delay_fun, i8* ()** %struct_field4, align 8
  %struct_field5 = getelementptr inbounds { i8* ()*, i8*, i1 }, { i8* ()*, i8*, i1 }* %thunk_sturct, i32 0, i32 1
  store i8* null, i8** %struct_field5, align 8
  %struct_field6 = getelementptr inbounds { i8* ()*, i8*, i1 }, { i8* ()*, i8*, i1 }* %thunk_sturct, i32 0, i32 2
  store i1 false, i1* %struct_field6, align 1
  store { i8* ()*, i8*, i1 }* %thunk_sturct, { i8* ()*, i8*, i1 }** %x, align 8
  %x7 = load { i8* ()*, i8*, i1 }*, { i8* ()*, i8*, i1 }** %x, align 8
  %x8 = load { i8* ()*, i8*, i1 }*, { i8* ()*, i8*, i1 }** %x, align 8
  %struct_field9 = getelementptr inbounds { i8* ()*, i8*, i1 }, { i8* ()*, i8*, i1 }* %x8, i32 0, i32 0
  %closure_ptr = load i8* ()*, i8* ()** %struct_field9, align 8
  %casted_clptr = bitcast i8* ()* %closure_ptr to { i32 (i8*, i1)*, i8* }*
  %struct_field10 = getelementptr inbounds { i32 (i8*, i1)*, i8* }, { i32 (i8*, i1)*, i8* }* %casted_clptr, i32 0, i32 0
  %fdef = load i32 (i8*, i1)*, i32 (i8*, i1)** %struct_field10, align 8
  %struct_field11 = getelementptr inbounds { i32 (i8*, i1)*, i8* }, { i32 (i8*, i1)*, i8* }* %casted_clptr, i32 0, i32 1
  %cap = load i8*, i8** %struct_field11, align 8
  %apply_result = call i32 %fdef(i8* %cap, i1 false)
  %struct_field12 = getelementptr inbounds { i8* ()*, i8*, i1 }, { i8* ()*, i8*, i1 }* %x7, i32 0, i32 1
  store i8* inttoptr (i32 %apply_result to i8*), i8** %struct_field12, align 8
  %printf = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @fmt.2, i32 0, i32 0), i32 %apply_result)
  ret i32 0
}

declare i8* @Force({ i8* ()*, i8*, i1 }*)

declare noalias i8* @malloc(i32)

define i32 @lambda(i8* %0, i1 %unit) {
entry:
  %1 = alloca i8*, align 8
  store i8* %0, i8** %1, align 8
  %2 = load i8*, i8** %1, align 8
  %cap = bitcast i8* %2 to {}*
  %unit1 = alloca i1, align 1
  store i1 %unit, i1* %unit1, align 1
  ret i32 1
}

declare i32 @printf(i8*, ...)

