datatype List = Nil | Cons of ((unit -> int) * (unit -> List));
fun : (unit -> ((unit -> ((unit -> int) -> int)) -> ((unit -> List) -> List))):
map unit = \(((unit -> ((unit -> int) -> int)) -> ((unit -> List) -> List)))f -> \(((unit -> List) -> List))xs -> if (xs ()).T == "Cons" 
 then let y = (xs ())@Cons.0, ys = (xs ())@Cons.1 in Cons (THUNK: ((f ()) y), THUNK: (((map ()) f) ys)) 
 else if (xs ()).T == "Nil" 
 then Nil  
 else (begin println"Case not matched", no match);

fun : (unit -> ((unit -> int) -> int)):
addone unit = \(((unit -> int) -> int))x -> (x ()) + 1;

fun : (unit -> ((unit -> unit) -> List)):
nat unit = \(((unit -> unit) -> List))u -> Cons (THUNK: 1, THUNK: (((map ()) addone) THUNK: ((nat ()) THUNK: ())));

fun : (unit -> ((unit -> List) -> ((unit -> int) -> List))):
take unit = \(((unit -> List) -> 
                ((unit -> int) -> List)))l -> 
                    \(((unit -> int) -> List))i -> 
 if (i ()) == 0 
 then Nil  
 else if (l ()).T == "Cons" 
 then let y = (l ())@Cons.0,
         ys = (l ())@Cons.1 
      in Cons (y, THUNK: (((take ()) ys) THUNK: (i ()) - 1)) 
 else if (l ()).T == "Nil" 
 then Nil  
 else (begin println"Case not matched", no match);

fun : (unit -> ((unit -> List) -> ((unit -> int) -> int))):
takePrint unit = \(((unit -> List) -> ((unit -> int) -> int)))l -> \(((unit -> int) -> int))i -> if (i ()) == 0 
 then 0 
 else if (l ()).T == "Cons" 
 then let y = (l ())@Cons.0, ys = (l ())@Cons.1 in (begin println(y ()), (((takePrint ()) ys) THUNK: (i ()) - 1)) 
 else if (l ()).T == "Nil" 
 then 0 
 else (begin println"Case not matched", no match);
(((takePrint ()) THUNK: ((nat ()) THUNK: ())) THUNK: 25);
