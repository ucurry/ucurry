State 0:
## Known stack suffix:
##
## LR(1) items:
program' -> . program [ # ]
## Transitions:
-- On program shift to state 1
-- On defs shift to state 2
## Reductions:
-- On UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN
--   reduce production defs ->

State 1:
## Known stack suffix:
## program
## LR(1) items:
program' -> program . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept program

State 2:
## Known stack suffix:
## defs
## LR(1) items:
defs -> defs . fundef SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
defs -> defs . vardef SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
defs -> defs . datatypedef SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
defs -> defs . exp SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
program -> defs . EOF [ # ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRTYPE shift to state 12
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTTYPE shift to state 13
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On FUNCTION shift to state 124
-- On EOF shift to state 132
-- On DATATYPE shift to state 133
-- On CASE shift to state 43
-- On CAPNAME shift to state 143
-- On BOOLTYPE shift to state 15
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On vardef shift to state 144
-- On unop shift to state 46
-- On typ shift to state 146
-- On literal shift to state 47
-- On lambda shift to state 48
-- On funtype shift to state 34
-- On fundef shift to state 150
-- On exp shift to state 152
-- On datatypedef shift to state 154
-- On binop shift to state 54
## Reductions:

State 3:
## Known stack suffix:
## UNITTYPE
## LR(1) items:
typ -> UNITTYPE . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> UNITTYPE

State 4:
## Known stack suffix:
## UNIT
## LR(1) items:
literal -> UNIT . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production literal -> UNIT

State 5:
## Known stack suffix:
## TL
## LR(1) items:
unop -> TL . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 123
-- On binop shift to state 54
## Reductions:

State 6:
## Known stack suffix:
## STRINGLIT
## LR(1) items:
literal -> STRINGLIT . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production literal -> STRINGLIT

State 7:
## Known stack suffix:
## NOT
## LR(1) items:
unop -> NOT . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 122
-- On binop shift to state 54
## Reductions:

State 8:
## Known stack suffix:
## NEG
## LR(1) items:
unop -> NEG . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 121
-- On binop shift to state 54
## Reductions:

State 9:
## Known stack suffix:
## NAME
## LR(1) items:
exp -> NAME . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp -> NAME . ASN exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On ASN shift to state 10
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> NAME

State 10:
## Known stack suffix:
## NAME ASN
## LR(1) items:
exp -> NAME ASN . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 120
-- On binop shift to state 54
## Reductions:

State 11:
## Known stack suffix:
## LET
## LR(1) items:
exp -> LET . bindings IN exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On STRTYPE shift to state 12
-- On INTTYPE shift to state 13
-- On CAPNAME shift to state 14
-- On BOOLTYPE shift to state 15
-- On typ shift to state 16
-- On funtype shift to state 34
-- On bindings shift to state 112
## Reductions:

State 12:
## Known stack suffix:
## STRTYPE
## LR(1) items:
typ -> STRTYPE . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> STRTYPE

State 13:
## Known stack suffix:
## INTTYPE
## LR(1) items:
typ -> INTTYPE . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> INTTYPE

State 14:
## Known stack suffix:
## CAPNAME
## LR(1) items:
typ -> CAPNAME . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> CAPNAME

State 15:
## Known stack suffix:
## BOOLTYPE
## LR(1) items:
typ -> BOOLTYPE . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> BOOLTYPE

State 16:
## Known stack suffix:
## typ
## LR(1) items:
bindings -> typ . NAME ASN exp [ IN COMMA ]
funtype -> typ . ARROW typ [ NAME LISTTYPE ARROW ]
typ -> typ . LISTTYPE [ NAME LISTTYPE ARROW ]
## Transitions:
-- On NAME shift to state 17
-- On LISTTYPE shift to state 31
-- On ARROW shift to state 32
## Reductions:

State 17:
## Known stack suffix:
## typ NAME
## LR(1) items:
bindings -> typ NAME . ASN exp [ IN COMMA ]
## Transitions:
-- On ASN shift to state 18
## Reductions:

State 18:
## Known stack suffix:
## typ NAME ASN
## LR(1) items:
bindings -> typ NAME ASN . exp [ IN COMMA ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 111
-- On binop shift to state 54
## Reductions:

State 19:
## Known stack suffix:
## LBRACKET
## LR(1) items:
literal -> LBRACKET . literal_list RBRACKET [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On STRINGLIT shift to state 6
-- On LBRACKET shift to state 19
-- On INTEGER shift to state 20
-- On BOOL shift to state 21
-- On literal_list shift to state 22
-- On literal shift to state 26
## Reductions:
-- On RBRACKET COMMA
--   reduce production literal_list ->

State 20:
## Known stack suffix:
## INTEGER
## LR(1) items:
literal -> INTEGER . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production literal -> INTEGER

State 21:
## Known stack suffix:
## BOOL
## LR(1) items:
literal -> BOOL . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production literal -> BOOL

State 22:
## Known stack suffix:
## LBRACKET literal_list
## LR(1) items:
literal -> LBRACKET literal_list . RBRACKET [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
literal_list -> literal_list . COMMA literal [ RBRACKET COMMA ]
## Transitions:
-- On RBRACKET shift to state 23
-- On COMMA shift to state 24
## Reductions:

State 23:
## Known stack suffix:
## LBRACKET literal_list RBRACKET
## LR(1) items:
literal -> LBRACKET literal_list RBRACKET . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACKET RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DOUBLEARROW DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production literal -> LBRACKET literal_list RBRACKET

State 24:
## Known stack suffix:
## literal_list COMMA
## LR(1) items:
literal_list -> literal_list COMMA . literal [ RBRACKET COMMA ]
## Transitions:
-- On UNIT shift to state 4
-- On STRINGLIT shift to state 6
-- On LBRACKET shift to state 19
-- On INTEGER shift to state 20
-- On BOOL shift to state 21
-- On literal shift to state 25
## Reductions:

State 25:
## Known stack suffix:
## literal_list COMMA literal
## LR(1) items:
literal_list -> literal_list COMMA literal . [ RBRACKET COMMA ]
## Transitions:
## Reductions:
-- On RBRACKET COMMA
--   reduce production literal_list -> literal_list COMMA literal

State 26:
## Known stack suffix:
## literal
## LR(1) items:
literal_list -> literal . [ RBRACKET COMMA ]
## Transitions:
## Reductions:
-- On RBRACKET COMMA
--   reduce production literal_list -> literal

State 27:
## Known stack suffix:
## LBRACE
## LR(1) items:
exp -> LBRACE . exp args RBRACE [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 106
-- On binop shift to state 54
## Reductions:

State 28:
## Known stack suffix:
## LAMBDA
## LR(1) items:
lambda -> LAMBDA . LBRACE funtype RBRACE formals ARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On LBRACE shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## LAMBDA LBRACE
## LR(1) items:
lambda -> LAMBDA LBRACE . funtype RBRACE formals ARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On STRTYPE shift to state 12
-- On INTTYPE shift to state 13
-- On CAPNAME shift to state 14
-- On BOOLTYPE shift to state 15
-- On typ shift to state 30
-- On funtype shift to state 35
## Reductions:

State 30:
## Known stack suffix:
## typ
## LR(1) items:
funtype -> typ . ARROW typ [ RBRACE LISTTYPE COLON ARROW ]
typ -> typ . LISTTYPE [ LISTTYPE ARROW ]
## Transitions:
-- On LISTTYPE shift to state 31
-- On ARROW shift to state 32
## Reductions:

State 31:
## Known stack suffix:
## typ LISTTYPE
## LR(1) items:
typ -> typ LISTTYPE . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> typ LISTTYPE

State 32:
## Known stack suffix:
## typ ARROW
## LR(1) items:
funtype -> typ ARROW . typ [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On STRTYPE shift to state 12
-- On INTTYPE shift to state 13
-- On CAPNAME shift to state 14
-- On BOOLTYPE shift to state 15
-- On typ shift to state 33
-- On funtype shift to state 34
## Reductions:

State 33:
## Known stack suffix:
## typ ARROW typ
## LR(1) items:
funtype -> typ . ARROW typ [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
funtype -> typ ARROW typ . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
typ -> typ . LISTTYPE [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
-- On LISTTYPE shift to state 31
## Reductions:
-- On SEMI RBRACE NAME COLON BAR ARROW
--   reduce production funtype -> typ ARROW typ

State 34:
## Known stack suffix:
## funtype
## LR(1) items:
typ -> funtype . [ SEMI RBRACE NAME LISTTYPE COLON BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMI RBRACE NAME LISTTYPE COLON BAR ARROW
--   reduce production typ -> funtype

State 35:
## Known stack suffix:
## LAMBDA LBRACE funtype
## LR(1) items:
lambda -> LAMBDA LBRACE funtype . RBRACE formals ARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
typ -> funtype . [ LISTTYPE ARROW ]
## Transitions:
-- On RBRACE shift to state 36
## Reductions:
-- On LISTTYPE ARROW
--   reduce production typ -> funtype

State 36:
## Known stack suffix:
## LAMBDA LBRACE funtype RBRACE
## LR(1) items:
lambda -> LAMBDA LBRACE funtype RBRACE . formals ARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On NAME shift to state 37
-- On formals shift to state 38
## Reductions:

State 37:
## Known stack suffix:
## NAME
## LR(1) items:
formals -> NAME . [ NAME ASN ARROW ]
## Transitions:
## Reductions:
-- On NAME ASN ARROW
--   reduce production formals -> NAME

State 38:
## Known stack suffix:
## LAMBDA LBRACE funtype RBRACE formals
## LR(1) items:
formals -> formals . NAME [ NAME ARROW ]
lambda -> LAMBDA LBRACE funtype RBRACE formals . ARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On NAME shift to state 39
-- On ARROW shift to state 40
## Reductions:

State 39:
## Known stack suffix:
## formals NAME
## LR(1) items:
formals -> formals NAME . [ NAME ASN ARROW ]
## Transitions:
## Reductions:
-- On NAME ASN ARROW
--   reduce production formals -> formals NAME

State 40:
## Known stack suffix:
## LAMBDA LBRACE funtype RBRACE formals ARROW
## LR(1) items:
lambda -> LAMBDA LBRACE funtype RBRACE formals ARROW . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 105
-- On binop shift to state 54
## Reductions:

State 41:
## Known stack suffix:
## IF
## LR(1) items:
exp -> IF . exp THEN exp ELSE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 100
-- On binop shift to state 54
## Reductions:

State 42:
## Known stack suffix:
## HD
## LR(1) items:
unop -> HD . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 99
-- On binop shift to state 54
## Reductions:

State 43:
## Known stack suffix:
## CASE
## LR(1) items:
exp -> CASE . exp OF case_exp_list [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 84
-- On binop shift to state 54
## Reductions:

State 44:
## Known stack suffix:
## CAPNAME
## LR(1) items:
exp -> CAPNAME . exp_opt [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp_opt shift to state 82
-- On exp shift to state 83
-- On binop shift to state 54
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp_opt ->
** Conflict on UNIT TL STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN

State 45:
## Known stack suffix:
## BEGIN
## LR(1) items:
exp -> BEGIN . exp_list [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp_list shift to state 49
-- On exp shift to state 81
-- On binop shift to state 54
## Reductions:

State 46:
## Known stack suffix:
## unop
## LR(1) items:
exp -> unop . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> unop

State 47:
## Known stack suffix:
## literal
## LR(1) items:
exp -> literal . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> literal

State 48:
## Known stack suffix:
## lambda
## LR(1) items:
exp -> lambda . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> lambda

State 49:
## Known stack suffix:
## BEGIN exp_list
## LR(1) items:
exp -> BEGIN exp_list . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp_list -> exp_list . COMMA exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On COMMA shift to state 50
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> BEGIN exp_list
** Conflict on COMMA

State 50:
## Known stack suffix:
## exp_list COMMA
## LR(1) items:
exp_list -> exp_list COMMA . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 51
-- On binop shift to state 54
## Reductions:

State 51:
## Known stack suffix:
## exp_list COMMA exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp_list -> exp_list COMMA exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp_list -> exp_list COMMA exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 52:
## Known stack suffix:
## exp TIMES
## LR(1) items:
binop -> exp TIMES . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 53
-- On binop shift to state 54
## Reductions:

State 53:
## Known stack suffix:
## exp TIMES exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp TIMES exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production binop -> exp TIMES exp

State 54:
## Known stack suffix:
## binop
## LR(1) items:
exp -> binop . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> binop

State 55:
## Known stack suffix:
## exp SUB
## LR(1) items:
binop -> exp SUB . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 56
-- On binop shift to state 54
## Reductions:

State 56:
## Known stack suffix:
## exp SUB exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp SUB exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
## Reductions:
-- On UNIT TL THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production binop -> exp SUB exp

State 57:
## Known stack suffix:
## exp MOD
## LR(1) items:
binop -> exp MOD . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 58
-- On binop shift to state 54
## Reductions:

State 58:
## Known stack suffix:
## exp MOD exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp MOD exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production binop -> exp MOD exp

State 59:
## Known stack suffix:
## exp DIVIDE
## LR(1) items:
binop -> exp DIVIDE . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 60
-- On binop shift to state 54
## Reductions:

State 60:
## Known stack suffix:
## exp DIVIDE exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp DIVIDE exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production binop -> exp DIVIDE exp

State 61:
## Known stack suffix:
## exp OR
## LR(1) items:
binop -> exp OR . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 62
-- On binop shift to state 54
## Reductions:

State 62:
## Known stack suffix:
## exp OR exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp OR exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IN IF HD ELSE COMMA CASE CAPNAME BOOL BEGIN BAR
--   reduce production binop -> exp OR exp

State 63:
## Known stack suffix:
## exp NEQ
## LR(1) items:
binop -> exp NEQ . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 64
-- On binop shift to state 54
## Reductions:

State 64:
## Known stack suffix:
## exp NEQ exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp NEQ exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp NEQ exp

State 65:
## Known stack suffix:
## exp ADD
## LR(1) items:
binop -> exp ADD . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 66
-- On binop shift to state 54
## Reductions:

State 66:
## Known stack suffix:
## exp ADD exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp ADD exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
## Reductions:
-- On UNIT TL THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production binop -> exp ADD exp

State 67:
## Known stack suffix:
## exp LESS
## LR(1) items:
binop -> exp LESS . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 68
-- On binop shift to state 54
## Reductions:

State 68:
## Known stack suffix:
## exp LESS exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp LESS exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp LESS exp

State 69:
## Known stack suffix:
## exp LEQ
## LR(1) items:
binop -> exp LEQ . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 70
-- On binop shift to state 54
## Reductions:

State 70:
## Known stack suffix:
## exp LEQ exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp LEQ exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp LEQ exp

State 71:
## Known stack suffix:
## exp GREATER
## LR(1) items:
binop -> exp GREATER . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 72
-- On binop shift to state 54
## Reductions:

State 72:
## Known stack suffix:
## exp GREATER exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp GREATER exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp GREATER exp

State 73:
## Known stack suffix:
## exp GEQ
## LR(1) items:
binop -> exp GEQ . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 74
-- On binop shift to state 54
## Reductions:

State 74:
## Known stack suffix:
## exp GEQ exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp GEQ exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp GEQ exp

State 75:
## Known stack suffix:
## exp EQUAL
## LR(1) items:
binop -> exp EQUAL . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 76
-- On binop shift to state 54
## Reductions:

State 76:
## Known stack suffix:
## exp EQUAL exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp EQUAL exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On MOD shift to state 57
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp EQUAL exp

State 77:
## Known stack suffix:
## exp CONS
## LR(1) items:
binop -> exp CONS . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 78
-- On binop shift to state 54
## Reductions:

State 78:
## Known stack suffix:
## exp CONS exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp CONS exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IN IF HD ELSE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp CONS exp

State 79:
## Known stack suffix:
## exp AND
## LR(1) items:
binop -> exp AND . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 80
-- On binop shift to state 54
## Reductions:

State 80:
## Known stack suffix:
## exp AND exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp AND exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OR OF NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IN IF HD ELSE COMMA CASE CAPNAME BOOL BEGIN BAR AND
--   reduce production binop -> exp AND exp

State 81:
## Known stack suffix:
## exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp_list -> exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp_list -> exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 82:
## Known stack suffix:
## CAPNAME exp_opt
## LR(1) items:
exp -> CAPNAME exp_opt . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> CAPNAME exp_opt

State 83:
## Known stack suffix:
## exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp_opt -> exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp_opt -> exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 84:
## Known stack suffix:
## CASE exp
## LR(1) items:
binop -> exp . ADD exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . SUB exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . MOD exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LESS exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . AND exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . OR exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . CONS exp [ TIMES SUB OR OF NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
exp -> CASE exp . OF case_exp_list [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On OF shift to state 85
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:

State 85:
## Known stack suffix:
## CASE exp OF
## LR(1) items:
exp -> CASE exp OF . case_exp_list [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On WILDCARD shift to state 86
-- On UNIT shift to state 4
-- On STRINGLIT shift to state 6
-- On NAME shift to state 87
-- On LBRACKET shift to state 19
-- On INTEGER shift to state 20
-- On CAPNAME shift to state 88
-- On BOOL shift to state 21
-- On pattern shift to state 91
-- On literal shift to state 90
-- On case_exp_list shift to state 94
## Reductions:

State 86:
## Known stack suffix:
## WILDCARD
## LR(1) items:
pattern -> WILDCARD . [ DOUBLEARROW ]
## Transitions:
## Reductions:
-- On DOUBLEARROW
--   reduce production pattern -> WILDCARD

State 87:
## Known stack suffix:
## NAME
## LR(1) items:
pattern -> NAME . [ DOUBLEARROW ]
## Transitions:
## Reductions:
-- On DOUBLEARROW
--   reduce production pattern -> NAME

State 88:
## Known stack suffix:
## CAPNAME
## LR(1) items:
pattern -> CAPNAME . [ DOUBLEARROW ]
pattern -> CAPNAME . pattern [ DOUBLEARROW ]
## Transitions:
-- On WILDCARD shift to state 86
-- On UNIT shift to state 4
-- On STRINGLIT shift to state 6
-- On NAME shift to state 87
-- On LBRACKET shift to state 19
-- On INTEGER shift to state 20
-- On CAPNAME shift to state 88
-- On BOOL shift to state 21
-- On pattern shift to state 89
-- On literal shift to state 90
## Reductions:
-- On DOUBLEARROW
--   reduce production pattern -> CAPNAME

State 89:
## Known stack suffix:
## CAPNAME pattern
## LR(1) items:
pattern -> CAPNAME pattern . [ DOUBLEARROW ]
## Transitions:
## Reductions:
-- On DOUBLEARROW
--   reduce production pattern -> CAPNAME pattern

State 90:
## Known stack suffix:
## literal
## LR(1) items:
pattern -> literal . [ DOUBLEARROW ]
## Transitions:
## Reductions:
-- On DOUBLEARROW
--   reduce production pattern -> literal

State 91:
## Known stack suffix:
## pattern
## LR(1) items:
case_exp_list -> pattern . DOUBLEARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On DOUBLEARROW shift to state 92
## Reductions:

State 92:
## Known stack suffix:
## pattern DOUBLEARROW
## LR(1) items:
case_exp_list -> pattern DOUBLEARROW . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 93
-- On binop shift to state 54
## Reductions:

State 93:
## Known stack suffix:
## pattern DOUBLEARROW exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
case_exp_list -> pattern DOUBLEARROW exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production case_exp_list -> pattern DOUBLEARROW exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 94:
## Known stack suffix:
## CASE exp OF case_exp_list
## LR(1) items:
case_exp_list -> case_exp_list . BAR pattern DOUBLEARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp -> CASE exp OF case_exp_list . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On BAR shift to state 95
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> CASE exp OF case_exp_list
** Conflict on BAR

State 95:
## Known stack suffix:
## case_exp_list BAR
## LR(1) items:
case_exp_list -> case_exp_list BAR . pattern DOUBLEARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On WILDCARD shift to state 86
-- On UNIT shift to state 4
-- On STRINGLIT shift to state 6
-- On NAME shift to state 87
-- On LBRACKET shift to state 19
-- On INTEGER shift to state 20
-- On CAPNAME shift to state 88
-- On BOOL shift to state 21
-- On pattern shift to state 96
-- On literal shift to state 90
## Reductions:

State 96:
## Known stack suffix:
## case_exp_list BAR pattern
## LR(1) items:
case_exp_list -> case_exp_list BAR pattern . DOUBLEARROW exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On DOUBLEARROW shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## case_exp_list BAR pattern DOUBLEARROW
## LR(1) items:
case_exp_list -> case_exp_list BAR pattern DOUBLEARROW . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 98
-- On binop shift to state 54
## Reductions:

State 98:
## Known stack suffix:
## case_exp_list BAR pattern DOUBLEARROW exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
case_exp_list -> case_exp_list BAR pattern DOUBLEARROW exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production case_exp_list -> case_exp_list BAR pattern DOUBLEARROW exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 99:
## Known stack suffix:
## HD exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
unop -> HD exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production unop -> HD exp

State 100:
## Known stack suffix:
## IF exp
## LR(1) items:
binop -> exp . ADD exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . SUB exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . TIMES exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . DIVIDE exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . MOD exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . EQUAL exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . NEQ exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LESS exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LEQ exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GREATER exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GEQ exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . AND exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . OR exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . CONS exp [ TIMES THEN SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
exp -> IF exp . THEN exp ELSE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On THEN shift to state 101
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:

State 101:
## Known stack suffix:
## IF exp THEN
## LR(1) items:
exp -> IF exp THEN . exp ELSE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 102
-- On binop shift to state 54
## Reductions:

State 102:
## Known stack suffix:
## IF exp THEN exp
## LR(1) items:
binop -> exp . ADD exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . SUB exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . MOD exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . LESS exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . AND exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . OR exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
binop -> exp . CONS exp [ TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL ELSE DIVIDE CONS AND ADD ]
exp -> IF exp THEN exp . ELSE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On ELSE shift to state 103
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:

State 103:
## Known stack suffix:
## IF exp THEN exp ELSE
## LR(1) items:
exp -> IF exp THEN exp ELSE . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 104
-- On binop shift to state 54
## Reductions:

State 104:
## Known stack suffix:
## IF exp THEN exp ELSE exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp -> IF exp THEN exp ELSE exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> IF exp THEN exp ELSE exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 105:
## Known stack suffix:
## LAMBDA LBRACE funtype RBRACE formals ARROW exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
lambda -> LAMBDA LBRACE funtype RBRACE formals ARROW exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production lambda -> LAMBDA LBRACE funtype RBRACE formals ARROW exp

State 106:
## Known stack suffix:
## LBRACE exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES SUB STRINGLIT OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
exp -> LBRACE exp . args RBRACE [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On STRINGLIT shift to state 6
-- On OR shift to state 61
-- On NOT shift to state 7
-- On NEQ shift to state 63
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On MOD shift to state 57
-- On LET shift to state 11
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On AND shift to state 79
-- On ADD shift to state 65
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 107
-- On binop shift to state 54
-- On args shift to state 108
## Reductions:

State 107:
## Known stack suffix:
## exp
## LR(1) items:
args -> exp . [ UNIT TL STRINGLIT RBRACE NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN ]
binop -> exp . ADD exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL STRINGLIT RBRACE NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN
--   reduce production args -> exp

State 108:
## Known stack suffix:
## LBRACE exp args
## LR(1) items:
args -> args . exp [ UNIT TL STRINGLIT RBRACE NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN ]
exp -> LBRACE exp args . RBRACE [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On RBRACE shift to state 109
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 110
-- On binop shift to state 54
## Reductions:

State 109:
## Known stack suffix:
## LBRACE exp args RBRACE
## LR(1) items:
exp -> LBRACE exp args RBRACE . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> LBRACE exp args RBRACE

State 110:
## Known stack suffix:
## args exp
## LR(1) items:
args -> args exp . [ UNIT TL STRINGLIT RBRACE NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN ]
binop -> exp . ADD exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES SUB STRINGLIT RBRACE OR NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IF HD GREATER GEQ EQUAL DIVIDE CONS CASE CAPNAME BOOL BEGIN AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL STRINGLIT RBRACE NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN
--   reduce production args -> args exp

State 111:
## Known stack suffix:
## typ NAME ASN exp
## LR(1) items:
bindings -> typ NAME ASN exp . [ IN COMMA ]
binop -> exp . ADD exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . SUB exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . MOD exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . LESS exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . AND exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . OR exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . CONS exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On IN COMMA
--   reduce production bindings -> typ NAME ASN exp

State 112:
## Known stack suffix:
## LET bindings
## LR(1) items:
bindings -> bindings . COMMA typ NAME ASN exp [ IN COMMA ]
exp -> LET bindings . IN exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On IN shift to state 113
-- On COMMA shift to state 115
## Reductions:

State 113:
## Known stack suffix:
## LET bindings IN
## LR(1) items:
exp -> LET bindings IN . exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 114
-- On binop shift to state 54
## Reductions:

State 114:
## Known stack suffix:
## LET bindings IN exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp -> LET bindings IN exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production exp -> LET bindings IN exp
** Conflict on TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD

State 115:
## Known stack suffix:
## bindings COMMA
## LR(1) items:
bindings -> bindings COMMA . typ NAME ASN exp [ IN COMMA ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On STRTYPE shift to state 12
-- On INTTYPE shift to state 13
-- On CAPNAME shift to state 14
-- On BOOLTYPE shift to state 15
-- On typ shift to state 116
-- On funtype shift to state 34
## Reductions:

State 116:
## Known stack suffix:
## bindings COMMA typ
## LR(1) items:
bindings -> bindings COMMA typ . NAME ASN exp [ IN COMMA ]
funtype -> typ . ARROW typ [ NAME LISTTYPE ARROW ]
typ -> typ . LISTTYPE [ NAME LISTTYPE ARROW ]
## Transitions:
-- On NAME shift to state 117
-- On LISTTYPE shift to state 31
-- On ARROW shift to state 32
## Reductions:

State 117:
## Known stack suffix:
## bindings COMMA typ NAME
## LR(1) items:
bindings -> bindings COMMA typ NAME . ASN exp [ IN COMMA ]
## Transitions:
-- On ASN shift to state 118
## Reductions:

State 118:
## Known stack suffix:
## bindings COMMA typ NAME ASN
## LR(1) items:
bindings -> bindings COMMA typ NAME ASN . exp [ IN COMMA ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 119
-- On binop shift to state 54
## Reductions:

State 119:
## Known stack suffix:
## bindings COMMA typ NAME ASN exp
## LR(1) items:
bindings -> bindings COMMA typ NAME ASN exp . [ IN COMMA ]
binop -> exp . ADD exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . SUB exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . MOD exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . LESS exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . AND exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . OR exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
binop -> exp . CONS exp [ TIMES SUB OR NEQ MOD LESS LEQ IN GREATER GEQ EQUAL DIVIDE CONS COMMA AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On IN COMMA
--   reduce production bindings -> bindings COMMA typ NAME ASN exp

State 120:
## Known stack suffix:
## NAME ASN exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
exp -> NAME ASN exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On UNIT TL THEN STRINGLIT SEMI RBRACE OF NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IN IF HD ELSE COMMA CASE CAPNAME BOOL BEGIN BAR
--   reduce production exp -> NAME ASN exp

State 121:
## Known stack suffix:
## NEG exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
unop -> NEG exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production unop -> NEG exp

State 122:
## Known stack suffix:
## NOT exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
unop -> NOT exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production unop -> NOT exp

State 123:
## Known stack suffix:
## TL exp
## LR(1) items:
binop -> exp . ADD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . SUB exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . TIMES exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . DIVIDE exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . MOD exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . EQUAL exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . NEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LESS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . LEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GREATER exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . GEQ exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . AND exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . OR exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
binop -> exp . CONS exp [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
unop -> TL exp . [ UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD ]
## Transitions:
## Reductions:
-- On UNIT TL TIMES THEN SUB STRINGLIT SEMI RBRACE OR OF NOT NEQ NEG NAME MOD LET LESS LEQ LBRACKET LBRACE LAMBDA INTEGER IN IF HD GREATER GEQ EQUAL ELSE DIVIDE CONS COMMA CASE CAPNAME BOOL BEGIN BAR AND ADD
--   reduce production unop -> TL exp

State 124:
## Known stack suffix:
## FUNCTION
## LR(1) items:
fundef -> FUNCTION . COLON funtype COLON NAME formals ASN exp [ SEMI ]
## Transitions:
-- On COLON shift to state 125
## Reductions:

State 125:
## Known stack suffix:
## FUNCTION COLON
## LR(1) items:
fundef -> FUNCTION COLON . funtype COLON NAME formals ASN exp [ SEMI ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On STRTYPE shift to state 12
-- On INTTYPE shift to state 13
-- On CAPNAME shift to state 14
-- On BOOLTYPE shift to state 15
-- On typ shift to state 30
-- On funtype shift to state 126
## Reductions:

State 126:
## Known stack suffix:
## FUNCTION COLON funtype
## LR(1) items:
fundef -> FUNCTION COLON funtype . COLON NAME formals ASN exp [ SEMI ]
typ -> funtype . [ LISTTYPE ARROW ]
## Transitions:
-- On COLON shift to state 127
## Reductions:
-- On LISTTYPE ARROW
--   reduce production typ -> funtype

State 127:
## Known stack suffix:
## FUNCTION COLON funtype COLON
## LR(1) items:
fundef -> FUNCTION COLON funtype COLON . NAME formals ASN exp [ SEMI ]
## Transitions:
-- On NAME shift to state 128
## Reductions:

State 128:
## Known stack suffix:
## FUNCTION COLON funtype COLON NAME
## LR(1) items:
fundef -> FUNCTION COLON funtype COLON NAME . formals ASN exp [ SEMI ]
## Transitions:
-- On NAME shift to state 37
-- On formals shift to state 129
## Reductions:

State 129:
## Known stack suffix:
## FUNCTION COLON funtype COLON NAME formals
## LR(1) items:
formals -> formals . NAME [ NAME ASN ]
fundef -> FUNCTION COLON funtype COLON NAME formals . ASN exp [ SEMI ]
## Transitions:
-- On NAME shift to state 39
-- On ASN shift to state 130
## Reductions:

State 130:
## Known stack suffix:
## FUNCTION COLON funtype COLON NAME formals ASN
## LR(1) items:
fundef -> FUNCTION COLON funtype COLON NAME formals ASN . exp [ SEMI ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 131
-- On binop shift to state 54
## Reductions:

State 131:
## Known stack suffix:
## FUNCTION COLON funtype COLON NAME formals ASN exp
## LR(1) items:
binop -> exp . ADD exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . SUB exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . MOD exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LESS exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . AND exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . OR exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . CONS exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
fundef -> FUNCTION COLON funtype COLON NAME formals ASN exp . [ SEMI ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On SEMI
--   reduce production fundef -> FUNCTION COLON funtype COLON NAME formals ASN exp

State 132:
## Known stack suffix:
## defs EOF
## LR(1) items:
program -> defs EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production program -> defs EOF

State 133:
## Known stack suffix:
## DATATYPE
## LR(1) items:
datatypedef -> DATATYPE . CAPNAME ASN constructor_list [ SEMI ]
## Transitions:
-- On CAPNAME shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## DATATYPE CAPNAME
## LR(1) items:
datatypedef -> DATATYPE CAPNAME . ASN constructor_list [ SEMI ]
## Transitions:
-- On ASN shift to state 135
## Reductions:

State 135:
## Known stack suffix:
## DATATYPE CAPNAME ASN
## LR(1) items:
datatypedef -> DATATYPE CAPNAME ASN . constructor_list [ SEMI ]
## Transitions:
-- On CAPNAME shift to state 136
-- On constructor_list shift to state 139
-- On constructor shift to state 142
## Reductions:
-- On SEMI BAR
--   reduce production constructor_list ->

State 136:
## Known stack suffix:
## CAPNAME
## LR(1) items:
constructor -> CAPNAME . [ SEMI BAR ]
constructor -> CAPNAME . OF typ [ SEMI BAR ]
## Transitions:
-- On OF shift to state 137
## Reductions:
-- On SEMI BAR
--   reduce production constructor -> CAPNAME

State 137:
## Known stack suffix:
## CAPNAME OF
## LR(1) items:
constructor -> CAPNAME OF . typ [ SEMI BAR ]
## Transitions:
-- On UNITTYPE shift to state 3
-- On STRTYPE shift to state 12
-- On INTTYPE shift to state 13
-- On CAPNAME shift to state 14
-- On BOOLTYPE shift to state 15
-- On typ shift to state 138
-- On funtype shift to state 34
## Reductions:

State 138:
## Known stack suffix:
## CAPNAME OF typ
## LR(1) items:
constructor -> CAPNAME OF typ . [ SEMI BAR ]
funtype -> typ . ARROW typ [ SEMI LISTTYPE BAR ARROW ]
typ -> typ . LISTTYPE [ SEMI LISTTYPE BAR ARROW ]
## Transitions:
-- On LISTTYPE shift to state 31
-- On ARROW shift to state 32
## Reductions:
-- On SEMI BAR
--   reduce production constructor -> CAPNAME OF typ

State 139:
## Known stack suffix:
## DATATYPE CAPNAME ASN constructor_list
## LR(1) items:
constructor_list -> constructor_list . BAR constructor [ SEMI BAR ]
datatypedef -> DATATYPE CAPNAME ASN constructor_list . [ SEMI ]
## Transitions:
-- On BAR shift to state 140
## Reductions:
-- On SEMI
--   reduce production datatypedef -> DATATYPE CAPNAME ASN constructor_list

State 140:
## Known stack suffix:
## constructor_list BAR
## LR(1) items:
constructor_list -> constructor_list BAR . constructor [ SEMI BAR ]
## Transitions:
-- On CAPNAME shift to state 136
-- On constructor shift to state 141
## Reductions:

State 141:
## Known stack suffix:
## constructor_list BAR constructor
## LR(1) items:
constructor_list -> constructor_list BAR constructor . [ SEMI BAR ]
## Transitions:
## Reductions:
-- On SEMI BAR
--   reduce production constructor_list -> constructor_list BAR constructor

State 142:
## Known stack suffix:
## constructor
## LR(1) items:
constructor_list -> constructor . [ SEMI BAR ]
## Transitions:
## Reductions:
-- On SEMI BAR
--   reduce production constructor_list -> constructor

State 143:
## Known stack suffix:
## CAPNAME
## LR(1) items:
exp -> CAPNAME . exp_opt [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
typ -> CAPNAME . [ NAME LISTTYPE ARROW ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp_opt shift to state 82
-- On exp shift to state 83
-- On binop shift to state 54
## Reductions:
-- On TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
--   reduce production exp_opt ->
-- On NAME LISTTYPE ARROW
--   reduce production typ -> CAPNAME
** Conflict on NAME

State 144:
## Known stack suffix:
## defs vardef
## LR(1) items:
defs -> defs vardef . SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
-- On SEMI shift to state 145
## Reductions:

State 145:
## Known stack suffix:
## defs vardef SEMI
## LR(1) items:
defs -> defs vardef SEMI . [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
## Reductions:
-- On UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN
--   reduce production defs -> defs vardef SEMI

State 146:
## Known stack suffix:
## typ
## LR(1) items:
funtype -> typ . ARROW typ [ NAME LISTTYPE ARROW ]
typ -> typ . LISTTYPE [ NAME LISTTYPE ARROW ]
vardef -> typ . NAME ASN exp [ SEMI ]
## Transitions:
-- On NAME shift to state 147
-- On LISTTYPE shift to state 31
-- On ARROW shift to state 32
## Reductions:

State 147:
## Known stack suffix:
## typ NAME
## LR(1) items:
vardef -> typ NAME . ASN exp [ SEMI ]
## Transitions:
-- On ASN shift to state 148
## Reductions:

State 148:
## Known stack suffix:
## typ NAME ASN
## LR(1) items:
vardef -> typ NAME ASN . exp [ SEMI ]
## Transitions:
-- On UNIT shift to state 4
-- On TL shift to state 5
-- On STRINGLIT shift to state 6
-- On NOT shift to state 7
-- On NEG shift to state 8
-- On NAME shift to state 9
-- On LET shift to state 11
-- On LBRACKET shift to state 19
-- On LBRACE shift to state 27
-- On LAMBDA shift to state 28
-- On INTEGER shift to state 20
-- On IF shift to state 41
-- On HD shift to state 42
-- On CASE shift to state 43
-- On CAPNAME shift to state 44
-- On BOOL shift to state 21
-- On BEGIN shift to state 45
-- On unop shift to state 46
-- On literal shift to state 47
-- On lambda shift to state 48
-- On exp shift to state 149
-- On binop shift to state 54
## Reductions:

State 149:
## Known stack suffix:
## typ NAME ASN exp
## LR(1) items:
binop -> exp . ADD exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . SUB exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . MOD exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LESS exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . AND exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . OR exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . CONS exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
vardef -> typ NAME ASN exp . [ SEMI ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:
-- On SEMI
--   reduce production vardef -> typ NAME ASN exp

State 150:
## Known stack suffix:
## defs fundef
## LR(1) items:
defs -> defs fundef . SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
-- On SEMI shift to state 151
## Reductions:

State 151:
## Known stack suffix:
## defs fundef SEMI
## LR(1) items:
defs -> defs fundef SEMI . [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
## Reductions:
-- On UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN
--   reduce production defs -> defs fundef SEMI

State 152:
## Known stack suffix:
## defs exp
## LR(1) items:
binop -> exp . ADD exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . SUB exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . TIMES exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . DIVIDE exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . MOD exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . EQUAL exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . NEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LESS exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . LEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GREATER exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . GEQ exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . AND exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . OR exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
binop -> exp . CONS exp [ TIMES SUB SEMI OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD ]
defs -> defs exp . SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
-- On TIMES shift to state 52
-- On SUB shift to state 55
-- On SEMI shift to state 153
-- On OR shift to state 61
-- On NEQ shift to state 63
-- On MOD shift to state 57
-- On LESS shift to state 67
-- On LEQ shift to state 69
-- On GREATER shift to state 71
-- On GEQ shift to state 73
-- On EQUAL shift to state 75
-- On DIVIDE shift to state 59
-- On CONS shift to state 77
-- On AND shift to state 79
-- On ADD shift to state 65
## Reductions:

State 153:
## Known stack suffix:
## defs exp SEMI
## LR(1) items:
defs -> defs exp SEMI . [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
## Reductions:
-- On UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN
--   reduce production defs -> defs exp SEMI

State 154:
## Known stack suffix:
## defs datatypedef
## LR(1) items:
defs -> defs datatypedef . SEMI [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
-- On SEMI shift to state 155
## Reductions:

State 155:
## Known stack suffix:
## defs datatypedef SEMI
## LR(1) items:
defs -> defs datatypedef SEMI . [ UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN ]
## Transitions:
## Reductions:
-- On UNITTYPE UNIT TL STRTYPE STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTTYPE INTEGER IF HD FUNCTION EOF DATATYPE CASE CAPNAME BOOLTYPE BOOL BEGIN
--   reduce production defs -> defs datatypedef SEMI

