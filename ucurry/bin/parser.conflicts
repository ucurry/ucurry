
** Conflict (shift/reduce) in state 143.
** Token involved: NAME
** This state is reached from program after reading:

defs CAPNAME

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
(?)

** In state 143, looking ahead at NAME, shifting is permitted
** because of the following sub-derivation:

defs exp SEMI 
     CAPNAME exp_opt 
             exp 
             . NAME 

** In state 143, looking ahead at NAME, reducing production
** typ -> CAPNAME
** is permitted because of the following sub-derivation:

defs vardef SEMI 
     typ NAME ASN exp // lookahead token appears
     CAPNAME . 

** Conflict (shift/reduce) in state 114.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs LET bindings IN exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 114, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

LET bindings IN exp 
                binop 
                exp . TIMES exp 

** In state 114, looking ahead at TIMES, reducing production
** exp -> LET bindings IN exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
LET bindings IN exp . 

** Conflict (shift/reduce) in state 104.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs IF exp THEN exp ELSE exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 104, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

IF exp THEN exp ELSE exp 
                     binop 
                     exp . TIMES exp 

** In state 104, looking ahead at TIMES, reducing production
** exp -> IF exp THEN exp ELSE exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
IF exp THEN exp ELSE exp . 

** Conflict (shift/reduce) in state 98.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs CASE exp OF case_exp_list BAR pattern DOUBLEARROW exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 98, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

CASE exp OF case_exp_list 
            case_exp_list BAR pattern DOUBLEARROW exp 
                                                  binop 
                                                  exp . TIMES exp 

** In state 98, looking ahead at TIMES, reducing production
** case_exp_list -> case_exp_list BAR pattern DOUBLEARROW exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
CASE exp OF case_exp_list // lookahead token is inherited
            case_exp_list BAR pattern DOUBLEARROW exp . 

** Conflict (shift/reduce) in state 94.
** Token involved: BAR
** This state is reached from program after reading:

defs CASE exp OF pattern DOUBLEARROW CASE exp OF case_exp_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     CASE exp OF case_exp_list 
                 (?)

** In state 94, looking ahead at BAR, shifting is permitted
** because of the following sub-derivation:

pattern DOUBLEARROW exp 
                    CASE exp OF case_exp_list 
                                case_exp_list . BAR pattern DOUBLEARROW exp 

** In state 94, looking ahead at BAR, reducing production
** exp -> CASE exp OF case_exp_list
** is permitted because of the following sub-derivation:

case_exp_list BAR pattern DOUBLEARROW exp // lookahead token appears
pattern DOUBLEARROW exp // lookahead token is inherited
                    CASE exp OF case_exp_list . 

** Conflict (shift/reduce) in state 93.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs CASE exp OF pattern DOUBLEARROW exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 93, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

CASE exp OF case_exp_list 
            pattern DOUBLEARROW exp 
                                binop 
                                exp . TIMES exp 

** In state 93, looking ahead at TIMES, reducing production
** case_exp_list -> pattern DOUBLEARROW exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
CASE exp OF case_exp_list // lookahead token is inherited
            pattern DOUBLEARROW exp . 

** Conflict (shift/reduce) in state 83.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs CAPNAME exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 83, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

CAPNAME exp_opt 
        exp 
        binop 
        exp . TIMES exp 

** In state 83, looking ahead at TIMES, reducing production
** exp_opt -> exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
CAPNAME exp_opt // lookahead token is inherited
        exp . 

** Conflict (shift/reduce) in state 81.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs BEGIN exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 81, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

BEGIN exp_list 
      exp 
      binop 
      exp . TIMES exp 

** In state 81, looking ahead at TIMES, reducing production
** exp_list -> exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
BEGIN exp_list // lookahead token is inherited
      exp . 

** Conflict (shift/reduce) in state 51.
** Tokens involved: TIMES SUB OR NEQ MOD LESS LEQ GREATER GEQ EQUAL DIVIDE CONS AND ADD
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

defs BEGIN exp_list COMMA exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 51, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

BEGIN exp_list 
      exp_list COMMA exp 
                     binop 
                     exp . TIMES exp 

** In state 51, looking ahead at TIMES, reducing production
** exp_list -> exp_list COMMA exp
** is permitted because of the following sub-derivation:

binop 
exp TIMES exp // lookahead token appears
BEGIN exp_list // lookahead token is inherited
      exp_list COMMA exp . 

** Conflict (shift/reduce) in state 49.
** Token involved: COMMA
** This state is reached from program after reading:

defs BEGIN BEGIN exp_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     BEGIN exp_list 
           (?)

** In state 49, looking ahead at COMMA, reducing production
** exp -> BEGIN exp_list
** is permitted because of the following sub-derivation:

exp_list COMMA exp // lookahead token appears
exp // lookahead token is inherited
BEGIN exp_list . 

** In state 49, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

exp 
BEGIN exp_list 
      exp_list . COMMA exp 

** Conflict (shift/reduce) in state 44.
** Tokens involved: UNIT TL STRINGLIT NOT NEG NAME LET LBRACKET LBRACE LAMBDA INTEGER IF HD CASE CAPNAME BOOL BEGIN
** The following explanations concentrate on token UNIT.
** This state is reached from program after reading:

defs LBRACE CAPNAME

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs exp SEMI 
     (?)

** In state 44, looking ahead at UNIT, reducing production
** exp_opt ->
** is permitted because of the following sub-derivation:

LBRACE exp args RBRACE // lookahead token appears because args can begin with UNIT
       CAPNAME exp_opt // lookahead token is inherited
               . 

** In state 44, looking ahead at UNIT, shifting is permitted
** because of the following sub-derivation:

LBRACE exp args RBRACE 
       CAPNAME exp_opt 
               exp 
               literal 
               . UNIT 
