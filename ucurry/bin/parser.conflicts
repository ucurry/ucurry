
** Conflict (shift/reduce) in state 167.
** Token involved: DOT
** This state is reached from program after reading:

defs TL exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 167, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

unop 
TL exp 
   exp . DOT INTEGER 

** In state 167, looking ahead at DOT, reducing production
** unop -> TL exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
unop // lookahead token is inherited
TL exp . 

** Conflict (shift/reduce) in state 166.
** Token involved: DOT
** This state is reached from program after reading:

defs PRINTLN exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 166, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

unop 
PRINTLN exp 
        exp . DOT INTEGER 

** In state 166, looking ahead at DOT, reducing production
** unop -> PRINTLN exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
unop // lookahead token is inherited
PRINTLN exp . 

** Conflict (shift/reduce) in state 165.
** Token involved: DOT
** This state is reached from program after reading:

defs PRINT exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 165, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

unop 
PRINT exp 
      exp . DOT INTEGER 

** In state 165, looking ahead at DOT, reducing production
** unop -> PRINT exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
unop // lookahead token is inherited
PRINT exp . 

** Conflict (shift/reduce) in state 164.
** Token involved: DOT
** This state is reached from program after reading:

defs NOT exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 164, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

unop 
NOT exp 
    exp . DOT INTEGER 

** In state 164, looking ahead at DOT, reducing production
** unop -> NOT exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
unop // lookahead token is inherited
NOT exp . 

** Conflict (shift/reduce) in state 163.
** Token involved: DOT
** This state is reached from program after reading:

defs NEG exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 163, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

unop 
NEG exp 
    exp . DOT INTEGER 

** In state 163, looking ahead at DOT, reducing production
** unop -> NEG exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
unop // lookahead token is inherited
NEG exp . 

** Conflict (shift/reduce) in state 162.
** Token involved: DOT
** This state is reached from program after reading:

defs NAME ASN exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 162, looking ahead at DOT, reducing production
** exp -> NAME ASN exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
NAME ASN exp . 

** In state 162, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

NAME ASN exp 
         exp . DOT INTEGER 

** Conflict (shift/reduce) in state 156.
** Token involved: DOT
** This state is reached from program after reading:

defs LET bindings IN exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 156, looking ahead at DOT, reducing production
** exp -> LET bindings IN exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
LET bindings IN exp . 

** In state 156, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

LET bindings IN exp 
                exp . DOT INTEGER 

** Conflict (shift/reduce) in state 111.
** Token involved: DOT
** This state is reached from program after reading:

defs LAMBDA LBRACE funtype RBRACE formals ARROW exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 111, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

lambda 
LAMBDA LBRACE funtype RBRACE formals ARROW exp 
                                           exp . DOT INTEGER 

** In state 111, looking ahead at DOT, reducing production
** lambda -> LAMBDA LBRACE funtype RBRACE formals ARROW exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
lambda // lookahead token is inherited
LAMBDA LBRACE funtype RBRACE formals ARROW exp . 

** Conflict (shift/reduce) in state 110.
** Token involved: DOT
** This state is reached from program after reading:

defs IF exp THEN exp ELSE exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 110, looking ahead at DOT, reducing production
** exp -> IF exp THEN exp ELSE exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
IF exp THEN exp ELSE exp . 

** In state 110, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

IF exp THEN exp ELSE exp 
                     exp . DOT INTEGER 

** Conflict (shift/reduce) in state 108.
** Token involved: DOT
** This state is reached from program after reading:

defs exp AND exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 108, looking ahead at DOT, reducing production
** binop -> exp AND exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp AND exp . 

** In state 108, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp AND exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 106.
** Token involved: DOT
** This state is reached from program after reading:

defs exp CONS exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 106, looking ahead at DOT, reducing production
** binop -> exp CONS exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp CONS exp . 

** In state 106, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp CONS exp 
         exp . DOT INTEGER 

** Conflict (shift/reduce) in state 104.
** Token involved: DOT
** This state is reached from program after reading:

defs exp EQUAL exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 104, looking ahead at DOT, reducing production
** binop -> exp EQUAL exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp EQUAL exp . 

** In state 104, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp EQUAL exp 
          exp . DOT INTEGER 

** Conflict (shift/reduce) in state 102.
** Token involved: DOT
** This state is reached from program after reading:

defs exp GEQ exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 102, looking ahead at DOT, reducing production
** binop -> exp GEQ exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp GEQ exp . 

** In state 102, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp GEQ exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 100.
** Token involved: DOT
** This state is reached from program after reading:

defs exp GREATER exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 100, looking ahead at DOT, reducing production
** binop -> exp GREATER exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp GREATER exp . 

** In state 100, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp GREATER exp 
            exp . DOT INTEGER 

** Conflict (shift/reduce) in state 98.
** Token involved: DOT
** This state is reached from program after reading:

defs exp LEQ exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 98, looking ahead at DOT, reducing production
** binop -> exp LEQ exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp LEQ exp . 

** In state 98, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp LEQ exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 96.
** Token involved: DOT
** This state is reached from program after reading:

defs exp LESS exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 96, looking ahead at DOT, reducing production
** binop -> exp LESS exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp LESS exp . 

** In state 96, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp LESS exp 
         exp . DOT INTEGER 

** Conflict (shift/reduce) in state 94.
** Token involved: DOT
** This state is reached from program after reading:

defs exp ADD exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 94, looking ahead at DOT, reducing production
** binop -> exp ADD exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp ADD exp . 

** In state 94, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp ADD exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 92.
** Token involved: DOT
** This state is reached from program after reading:

defs exp NEQ exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 92, looking ahead at DOT, reducing production
** binop -> exp NEQ exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp NEQ exp . 

** In state 92, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp NEQ exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 90.
** Token involved: DOT
** This state is reached from program after reading:

defs exp OR exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 90, looking ahead at DOT, reducing production
** binop -> exp OR exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp OR exp . 

** In state 90, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp OR exp 
       exp . DOT INTEGER 

** Conflict (shift/reduce) in state 88.
** Token involved: DOT
** This state is reached from program after reading:

defs exp DIVIDE exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 88, looking ahead at DOT, reducing production
** binop -> exp DIVIDE exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp DIVIDE exp . 

** In state 88, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp DIVIDE exp 
           exp . DOT INTEGER 

** Conflict (shift/reduce) in state 86.
** Token involved: DOT
** This state is reached from program after reading:

defs exp MOD exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 86, looking ahead at DOT, reducing production
** binop -> exp MOD exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp MOD exp . 

** In state 86, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp MOD exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 84.
** Token involved: DOT
** This state is reached from program after reading:

defs exp SUB exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 84, looking ahead at DOT, reducing production
** binop -> exp SUB exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp SUB exp . 

** In state 84, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp SUB exp 
        exp . DOT INTEGER 

** Conflict (shift/reduce) in state 80.
** Token involved: DOT
** This state is reached from program after reading:

defs exp TIMES exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 80, looking ahead at DOT, reducing production
** binop -> exp TIMES exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
binop // lookahead token is inherited
exp TIMES exp . 

** In state 80, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

binop 
exp TIMES exp 
          exp . DOT INTEGER 

** Conflict (shift/reduce) in state 74.
** Token involved: DOT
** This state is reached from program after reading:

defs HD exp

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
defs EOF 
defs def SEMI 
     exp 
     (?)

** In state 74, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

unop 
HD exp 
   exp . DOT INTEGER 

** In state 74, looking ahead at DOT, reducing production
** unop -> HD exp
** is permitted because of the following sub-derivation:

exp DOT INTEGER // lookahead token appears
unop // lookahead token is inherited
HD exp . 
